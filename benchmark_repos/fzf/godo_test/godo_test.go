package test

import (
	"flag"
	"os"
	"testing"

	"github.com/compermane/ic-go/pkg/domain/executor"
	fzf "github.com/junegunn/fzf/src"
	"github.com/junegunn/fzf/src/algo"
	"github.com/junegunn/fzf/src/protector"
	"github.com/junegunn/fzf/src/tui"
	"github.com/junegunn/fzf/src/util"
)

var iteration int

func TestMain(m *testing.M) {
	flag.IntVar(&iteration, "iteration", 1000, "Iteração do algoritmo (benchmarking)",)
	flag.Parse()

	code := m.Run()
	os.Exit(code)
}

func TestGodo(t *testing.T) {
	funcs := []any{
		algo.Init,
		algo.FuzzyMatchV2,
		algo.FuzzyMatchV1,
		algo.ExactMatchNaive,
		algo.ExactMatchBoundary,
		algo.PrefixMatch,
		algo.SuffixMatch,
		algo.EqualMatch,
		algo.NormalizeRunes,
		fzf.NewChunkCache,
		(*fzf.ChunkCache).Clear,
		(*fzf.ChunkCache).Add,
		(*fzf.ChunkCache).Lookup,
		(*fzf.ChunkCache).Search,
		fzf.NewChunkList,
		(*fzf.Chunk).IsFull,
		fzf.CountItems,
		(*fzf.ChunkList).Push,
		(*fzf.ChunkList).Clear,
		(*fzf.ChunkList).Snapshot,
		fzf.Run,
		fzf.WriteTemporaryFile,
		fzf.NewHistory,
		(*fzf.Item).Index,
		(*fzf.Item).TrimLength,
		(*fzf.Item).Colors,
		(*fzf.Item).AsString,
		fzf.NewMatcher,
		(*fzf.Matcher).Loop,
		(*fzf.Matcher).Reset,
		(*fzf.Matcher).Stop,
		fzf.EmptyMerger,
		fzf.PassMerger,
		fzf.NewMerger,
		(*fzf.Merger).Revision,
		(*fzf.Merger).Length,
		(*fzf.Merger).First,
		(*fzf.Merger).FindIndex,
		(*fzf.Merger).Get,
		fzf.ParseOptions,
		fzf.BuildPattern,
		(*fzf.Pattern).IsEmpty,
		(*fzf.Pattern).AsString,
		(*fzf.Pattern).CacheKey,
		(*fzf.Pattern).Match,
		(*fzf.Pattern).MatchItem,
		protector.Protect,
		protector.Protect,
		fzf.NewReader,
		(*fzf.Reader).ReadSource,
		(*fzf.Result).Index,
		(fzf.ByOrder).Len,
		(fzf.ByOrder).Swap,
		(fzf.ByOrder).Less,
		(fzf.ByRelevance).Len,
		(fzf.ByRelevance).Swap,
		(fzf.ByRelevance).Less,
		(fzf.ByRelevanceTac).Len,
		(fzf.ByRelevanceTac).Swap,
		(fzf.ByRelevanceTac).Less,
		fzf.NewTerminal,
		(*fzf.Terminal).MaxFitAndPad,
		(*fzf.Terminal).Input,
		(*fzf.Terminal).UpdateCount,
		(*fzf.Terminal).UpdateHeader,
		(*fzf.Terminal).UpdateProgress,
		(*fzf.Terminal).UpdateList,
		(*fzf.Terminal).Loop,
		(fzf.Range).IsFull,
		fzf.RangesToString,
		(fzf.Token).String,
		(fzf.Delimiter).String,
		fzf.ParseRange,
		fzf.Tokenize,
		fzf.Transform,
		tui.HasFullscreenRenderer,
		(tui.Attr).Merge,
		(*tui.FullscreenRenderer).Init,
		(*tui.FullscreenRenderer).DefaultTheme,
		(*tui.FullscreenRenderer).Resize,
		(*tui.FullscreenRenderer).Pause,
		(*tui.FullscreenRenderer).Resume,
		(*tui.FullscreenRenderer).PassThrough,
		(*tui.FullscreenRenderer).Clear,
		(*tui.FullscreenRenderer).NeedScrollbarRedraw,
		(*tui.FullscreenRenderer).ShouldEmitResizeEvent,
		(*tui.FullscreenRenderer).Bell,
		(*tui.FullscreenRenderer).Refresh,
		(*tui.FullscreenRenderer).Close,
		(*tui.FullscreenRenderer).Size,
		(*tui.FullscreenRenderer).GetChar,
		(*tui.FullscreenRenderer).Top,
		(*tui.FullscreenRenderer).MaxX,
		(*tui.FullscreenRenderer).MaxY,
		(*tui.FullscreenRenderer).RefreshWindows,
		(*tui.FullscreenRenderer).NewWindow,
		(tui.EventType).String,
		(*tui.LightRenderer).Bell,
		(*tui.LightRenderer).PassThrough,
		tui.NewLightRenderer,
		(*tui.LightRenderer).Init,
		(*tui.LightRenderer).Resize,
		(*tui.LightRenderer).GetChar,
		(*tui.LightRenderer).Pause,
		(*tui.LightRenderer).Resume,
		(*tui.LightRenderer).Clear,
		(*tui.LightRenderer).NeedScrollbarRedraw,
		(*tui.LightRenderer).ShouldEmitResizeEvent,
		(*tui.LightRenderer).RefreshWindows,
		(*tui.LightRenderer).Refresh,
		(*tui.LightRenderer).Close,
		(*tui.LightRenderer).Top,
		(*tui.LightRenderer).MaxX,
		(*tui.LightRenderer).MaxY,
		(*tui.LightRenderer).NewWindow,
		(*tui.LightWindow).DrawBorder,
		(*tui.LightWindow).DrawHBorder,
		(*tui.LightWindow).Top,
		(*tui.LightWindow).Left,
		(*tui.LightWindow).Width,
		(*tui.LightWindow).Height,
		(*tui.LightWindow).Refresh,
		(*tui.LightWindow).X,
		(*tui.LightWindow).Y,
		(*tui.LightWindow).EncloseX,
		(*tui.LightWindow).EncloseY,
		(*tui.LightWindow).Enclose,
		(*tui.LightWindow).Move,
		(*tui.LightWindow).MoveAndClear,
		(*tui.LightWindow).Print,
		(*tui.LightWindow).CPrint,
		(*tui.LightWindow).LinkBegin,
		(*tui.LightWindow).LinkEnd,
		(*tui.LightWindow).Fill,
		(*tui.LightWindow).CFill,
		(*tui.LightWindow).FinishFill,
		(*tui.LightWindow).Erase,
		(*tui.LightWindow).EraseMaybe,
		tui.IsLightRendererSupported,
		(*tui.LightRenderer).DefaultTheme,
		(*tui.LightRenderer).Size,
		tui.IsLightRendererSupported,
		(*tui.LightRenderer).DefaultTheme,
		(*tui.LightRenderer).Size,
		tui.HasFullscreenRenderer,
		(*tui.FullscreenRenderer).Bell,
		(*tui.FullscreenRenderer).PassThrough,
		(*tui.FullscreenRenderer).Resize,
		(*tui.FullscreenRenderer).DefaultTheme,
		(tui.Attr).Merge,
		(*tui.FullscreenRenderer).Init,
		(*tui.FullscreenRenderer).Top,
		(*tui.FullscreenRenderer).MaxX,
		(*tui.FullscreenRenderer).MaxY,
		(*tui.FullscreenRenderer).Clear,
		(*tui.FullscreenRenderer).NeedScrollbarRedraw,
		(*tui.FullscreenRenderer).ShouldEmitResizeEvent,
		(*tui.FullscreenRenderer).Refresh,
		(*tui.FullscreenRenderer).Size,
		(*tui.FullscreenRenderer).GetChar,
		(*tui.FullscreenRenderer).Pause,
		(*tui.FullscreenRenderer).Resume,
		(*tui.FullscreenRenderer).Close,
		(*tui.FullscreenRenderer).RefreshWindows,
		(*tui.FullscreenRenderer).NewWindow,
		tui.TtyIn,
		tui.TtyOut,
		tui.TtyIn,
		tui.TtyOut,
		(tui.EventType).AsEvent,
		(tui.EventType).Int,
		(tui.EventType).Byte,
		(tui.Event).Comparable,
		(tui.Event).KeyName,
		tui.Key,
		tui.AltKey,
		tui.CtrlAltKey,
		(tui.Color).IsDefault,
		(tui.ColorAttr).IsColorDefined,
		tui.NewColorAttr,
		(tui.ColorAttr).Merge,
		tui.HexToColor,
		tui.NewColorPair,
		(tui.ColorPair).Fg,
		(tui.ColorPair).Bg,
		(tui.ColorPair).Attr,
		(tui.ColorPair).HasBg,
		(tui.ColorPair).WithAttr,
		(tui.ColorPair).MergeAttr,
		(tui.ColorPair).Merge,
		(tui.ColorPair).MergeNonDefault,
		(tui.MouseEvent).Mod,
		(tui.MouseEvent).Name,
		(tui.BorderShape).HasLeft,
		(tui.BorderShape).HasRight,
		(tui.BorderShape).HasTop,
		(tui.BorderShape).HasBottom,
		(tui.BorderShape).Visible,
		tui.MakeBorderStyle,
		tui.NewFullscreenRenderer,
		tui.EmptyTheme,
		tui.NoColorTheme,
		tui.InitTheme,
		util.AtExit,
		util.RunAtExitFuncs,
		util.NewAtomicBool,
		(*util.AtomicBool).Get,
		(*util.AtomicBool).Set,
		util.ToChars,
		util.RunesToChars,
		(*util.Chars).IsBytes,
		(*util.Chars).Bytes,
		(*util.Chars).NumLines,
		(*util.Chars).Get,
		(*util.Chars).Length,
		(*util.Chars).String,
		(*util.Chars).TrimLength,
		(*util.Chars).LeadingWhitespaces,
		(*util.Chars).TrailingWhitespaces,
		(*util.Chars).TrimTrailingWhitespaces,
		(*util.Chars).ToString,
		(*util.Chars).ToRunes,
		(*util.Chars).CopyRunes,
		(*util.Chars).Prepend,
		(*util.Chars).Lines,
		util.NewEventBox,
		(*util.EventBox).Wait,
		(*util.EventBox).Set,
		(*util.Events).Clear,
		(*util.EventBox).Peek,
		(*util.EventBox).Watch,
		(*util.EventBox).Unwatch,
		(*util.EventBox).WaitFor,
		util.MakeSlab,
		util.StringWidth,
		util.RunesWidth,
		util.Truncate,
		util.Max,
		util.Max16,
		util.Max32,
		util.Min,
		util.Min32,
		util.Constrain32,
		util.Constrain,
		util.AsUint16,
		util.DurWithin,
		util.IsTty,
		util.RunOnce,
		util.Once,
		util.RepeatToFill,
		util.ToKebabCase,
		util.CompareVersions,
		util.NewExecutor,
		(*util.Executor).ExecCommand,
		(*util.Executor).QuoteEntry,
		util.KillCommand,
		util.IsWindows,
		util.SetNonblock,
		util.Read,
		util.SetStdin,
		util.NewExecutor,
		(*util.Executor).ExecCommand,
		(*util.Executor).QuoteEntry,
		util.KillCommand,
		util.IsWindows,
		util.SetNonblock,
		util.Read,
		util.SetStdin,
		
		
	}

	// rcv := receiver.GetReceiver(cobra.Command{})
	// rcv.SetReceiverValues()

	executor.ExecuteFuncs(funcs, nil, "feedback_directed", 0, 60, 10, executor.DebugOpts{Dump: true, Debug: false, UseSequenceHashMap: true, Iteration: iteration})
}